// Code generated by cmd/cgo; DO NOT EDIT.

//line ibapi.go:1:1
package ibapi; import _cgo_unsafe "unsafe"

//go:generate go tool cgo ibapi.go

// NOTE: Before building, ensure you've exported these variables:
// CGO_LDFLAGS=<path_to_ib_cpp_api>/libTwsSocketClient.so
// CGO_CPP_FLAGS=-I<path_to_ib_cpp_api>

/*
#cgo CXXFLAGS: -std=c++11

#include <stdlib.h>
#include "ibapi.h"
*/
import _ "unsafe"

import (
	"runtime"
	"sync"
	"unsafe"
)

// *** Contract ***

// Contract represents a contract
type Contract struct {
	contract *_Ctype_struct_Contract
}

// NewContract creates a new contract
func NewContract(sym, secType, exch, contractMonth, currency string) *Contract {
	cSym, cSecType, cExch, cContractMonth, cCurrency := (_Cfunc_CString)(sym), (_Cfunc_CString)(secType),
		(_Cfunc_CString)(exch), (_Cfunc_CString)(contractMonth), (_Cfunc_CString)(currency)
	defer func() {
		func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cSym))
		func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cSecType))
		func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cExch))
		func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cContractMonth))
		func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cCurrency))
	}()
	c := &Contract{contract: (_Cfunc_new_contract)(cSym, cSecType, cExch, cContractMonth, cCurrency)}
	runtime.SetFinalizer(c, deleteContract)
	return c
}

func deleteContract(c *Contract) {
	func(_cgo0 *_Ctype_struct_Contract) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_delete_contract)(_cgo0);}(c.contract)
}

// Symbol returns the symbol from the contract
func (c *Contract) Symbol() string {
	return (_Cfunc_GoString)(func(_cgo0 *_Ctype_struct_Contract) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_contract_symbol)(_cgo0);}(c.contract))
}

// SecType returns the security type of the contract
func (c *Contract) SecType() string {
	return (_Cfunc_GoString)(func(_cgo0 *_Ctype_struct_Contract) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_contract_sec_type)(_cgo0);}(c.contract))
}

// Exchange returns the exchange of the contract
func (c *Contract) Exchange() string {
	return (_Cfunc_GoString)(func(_cgo0 *_Ctype_struct_Contract) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_contract_exchange)(_cgo0);}(c.contract))
}

// ContractMonth returns the contract month of the futures contract
func (c *Contract) ContractMonth() string {
	return (_Cfunc_GoString)(func(_cgo0 *_Ctype_struct_Contract) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_contract_month)(_cgo0);}(c.contract))
}

// Currency returns the currency used for the contract
func (c *Contract) Currency() string {
	return (_Cfunc_GoString)(func(_cgo0 *_Ctype_struct_Contract) *_Ctype_char {;	_cgoCheckPointer(_cgo0);	return (_Cfunc_contract_currency)(_cgo0);}(c.contract))
}

// *** EWrapper ***

type wrappers struct {
	m    map[_Ctype_long]EWrapper
	next _Ctype_long
	lock sync.Mutex
}

var (
	w = wrappers{m: make(map[_Ctype_long]EWrapper, 64)}
)

// OrderID represents an IB order ID
type OrderID = _Ctype_OrderId

// EWrapper represesnts an interface of IB callbacks
type EWrapper interface {
	NextValidId(orderID OrderID)
}

func findEWrapper(id _Ctype_long) EWrapper {
	w.lock.Lock()
	defer w.lock.Unlock()
	wrapper, ok := w.m[id]
	if !ok {
		// TODO: log error
		return nil
	}
	return wrapper
}

//export nextValidIDCallback
func nextValidIDCallback(id _Ctype_long, orderID _Ctype_OrderId) {
	if wrapper := findEWrapper(id); wrapper != nil {
		wrapper.NextValidId(orderID)
	}
}

// *** EClientSocket ***

// EClientSocket represents an IB client socket
type EClientSocket struct {
	sock *_Ctype_struct_ClientSock
	id   _Ctype_long
}

// NewEClientSocket returns a new client socket with the given EWrapper callbacks
func NewEClientSocket(wrapper EWrapper) *EClientSocket {
	w.lock.Lock()
	next := w.next
	w.m[next] = wrapper
	w.next++
	w.lock.Unlock()

	sock := &EClientSocket{sock: (_Cfunc_new_client_sock)(next), id: next}
	return sock
}

// EConnect attempts to connect to TWS/IBGateway on the given host/port and client ID
func (s *EClientSocket) EConnect(host string, port, clientID int) {
	cHost := (_Cfunc_CString)(host)
	defer func(_cgo0 _cgo_unsafe.Pointer) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_free)(_cgo0);}(unsafe.Pointer(cHost))
	func(_cgo0 *_Ctype_struct_ClientSock, _cgo1 *_Ctype_char, _cgo2 _Ctype_int, _cgo3 _Ctype_int) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_sock_econnect)(_cgo0, _cgo1, _cgo2, _cgo3);}(s.sock, cHost, _Ctype_int(port), _Ctype_int(clientID))
}

// EDisconnect attempts to disconnect from TWS/IBGateway
func (s *EClientSocket) EDisconnect() {
	func(_cgo0 *_Ctype_struct_ClientSock) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_sock_edisconnect)(_cgo0);}(s.sock)
}

// Delete frees the underlying CPP resources and removes the wrapper from the map
func (s *EClientSocket) Delete() {
	// First, get rid of the underlying socket to prevent callbacks
	func(_cgo0 *_Ctype_struct_ClientSock) {;	_cgoCheckPointer(_cgo0);	(_Cfunc_delete_client_sock)(_cgo0);}(s.sock)
	// Now remove the reference to the ewrapper from the map
	w.lock.Lock()
	delete(w.m, s.id)
	w.lock.Unlock()
}
